---
title: "Project 1 mt5767"
author: "PB, KA, HS"
date: "29/01/2021"
output:
  html_document:
    df_print: paged
  pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(ggplot2)
library(tidyverse)
library(plotly)

```

Here is a very basic skeleton guide to give a sense of what I expect from the assignment. Hopefully this helps. Not sure how much rmarkdown you have been exposed to, but in case you wanted to (learn to) use it, here you go. This pdf is generated from the code I sent, but changing the output in the first few lines to html_document will produce an html file. You can submit pdf, html, or word to moodle and you definitely don't have to use markdown (although it allows you to embed code and therefore avoids having to submit multiple files). Please ask if you aren't sure.

Okay, below would be a perfectly acceptable way to approach the assignment. I like emphasizing the importance of sharing and annotating code. So I hope this is a practice you can adopt. It won't affect your grade, but I do need to be able to follow along so I can see what you did if things dont quite look right. 

Equations may be the challenging part. To write an in-line equation or mathematical symbol, you us single dollar signs ($\sigma$) and an equation on its own line requires double dollar signs:

$$y = \alpha_0 + \alpha_1X$$

Use Teams to share issues tips and trick if you like, I will keep an eye on it.

Formatting wise, feel free to format as you like. I have sprinkled different markdown code in the document so you have examples of how to carry out basic formatting.

I dont want creating the markdown document to become the challenge, so I emphasize: 

1. word or latex is fine
2. help each other out
3. ask me if there is something wrong

## Question 1

We are given a species with four age classes. The dynamics of the species arise from  the sequence of sub-processes: survival, ageing, birth.

$\large{State~Model}$

$\large{Survival}$

A proportion of each state survives, denoted below as $u$, with age category having a specific survival probability; it is noted that all individuals in age category 4 die.

$$ u_{1(s),1,t} \thicksim binomial(n_{1, t-1}, 0.45) \\
u_{1(s),2,t} \thicksim binomial(n_{2,t-1}, 0.7) \\
u_{1(s),3,t} \thicksim binomial(n_{3,t-1}, 0.7) \\
u_{1(s),4,t} = 0 $$

$\large{Ageing}$

All individuals will age up due to the structure of the population. This leaves no individuals in the first class due to there being no age class younger than age class 1.

$$ u_{2(r),1,t} = 0 \\
u_{2(r),2,t} = u_{1(s),1,t} \\
u_{2(r),3,t} = u_{1(s),2,t} \\
u_{2(r),4,t} = u_{1(s),3,t} $$

$\large{Birth}$

In this model, only age categories 2 and 3 reproduce with their respective reproduction rates. These births will feed into the first age category. The number of individuals in age categories 2 and above are not effected in this sub-process

$$ u_{3(b),1,t} = u_{2(r),1,t} + b_{2,t} + b_{3,t} \\
u_{3(b),2,t} = u_{2(r),2,t} \\
u_{3(b),3,t} = u_{2(r),3,t} \\
u_{3(b),4,t} = u_{2(r),4,t} \\
where~\small{b_{2,t} \thicksim poisson(0.9*u_{2(r),2,t}) \\
b_{3,t} \thicksim poisson(1.9*u_{2(r),3,t})} $$


Hence, from the above sub-processes, our state model produces species abundance estimates for each category $i$ at time $t$:

$$ n_{i,t} = u_{3(b),i,t} ~~~~~~ \small{for~ i=1,...,4} $$

$\large{Observation~Model}$

Finally, we want to generate our observation model. It is stated there is no double counting, hence every observation estimate should be smaller than the state process model. By this methodology, the distribution was chosen as below:

$$ y_{i,t} \thicksim binomial(n_{i,t}, 0.5) ~~~~~~
\small{for~i=1,...,4}$$

Coding these models, a function was created for a four age species, which took inputs initial population, survival rates, birth rates, probability of detection and number of years to simulate

```{r}

# inputs
  # n0 - vector of initial population abundances by age
  # phi - vector of survival probabilities for each age
  # rho - vector of birth rates for each age
  # detect_p - probability of detecting an individual
  # nyears - number of years to simulate 
bas_ssm <- function(n0, phi, rho, detect_p, nyears) {
  
  # define matrix for state model variables
  # column for each age category; row per year
  state_mat <- matrix(0, nrow = nyears, ncol = length(n0))
  # add initial data
  state_mat[1, ] <- n0
  
  # define matrix for observation model variables
  obs_mat <- matrix(0, nrow = nyears, ncol = length(n0))
  # add initial observation
  obs_mat[1, ] <- rbinom(4, state_mat[1, ], detect_p)
  
  for (i in 2:nyears) {
    # survive 
    u1_1 <- rbinom(1, state_mat[i - 1, 1], phi[1])
    u1_2 <- rbinom(1, state_mat[i - 1, 2], phi[2])
    u1_3 <- rbinom(1, state_mat[i - 1, 3], phi[3])
    # u1_4 = 0
    
    # age
    # u2_1 = 0
    u2_2 <- u1_1
    u2_3 <- u1_2
    u2_4 <- u1_3
    
    # birth
    u3_1 <- rpois(1, rho[2] * u2_2) +
      rpois(1, rho[3] * u2_3)
    
    # overall
    state_mat[i, ] <- c(u3_1, u2_2, u2_3, u2_4)
    
    
    # observation model
    obs_mat[i, ] <- rbinom(4, state_mat[i, ], detect_p)
  }
  return(data.frame(Year = 1:nyears,
                    Abundance = c(state_mat, obs_mat),
                    Type = rep(c("State", "Observation"), each = nyears * 4),
                    State = rep(c("Age 1", "Age 2", "Age 3", "Age 4"), each = nyears,
                                times = 2)))
}

```

The variables were then coded for the above function, and it was run to simulate 25 years.

```{r}

n0 <- c(150, 70, 50, 30)
phi <- c(0.45, 0.7, 0.7, 0)
rho <- c(0, 0.9, 1.9, 0)

# set seed for replicability
set.seed(2791)

model <- bas_ssm(n0, phi, rho, 0.5, 25)

```

Looking at the results graphically looking at the overall population dynamics, combining the age groups

```{r, echo=F, message=F}

ov_abundance <- model %>%
  group_by(Type, Year) %>%
  summarise(`Overall Abundance` = 
              sum(Abundance)) %>%
  ggplot(aes(x = Year, y = `Overall Abundance`, col = Type)) +
  geom_line() +
  labs(col="Model") +
  ylab("Abundance") + 
  ggtitle("Figure 1.1 - Overall Abundance")

ggplotly(ov_abundance, ttoltip = c("Overall Abundance", "Year"))

```

Then splitting the models by age group

```{r, echo=F}

age_abundance <- ggplot(model, aes(x = Year, y = Abundance, col = Type)) +
  geom_line() +
  facet_wrap(~ State) +
  labs(col="Model") +
  ggtitle("Figure 1.2")

ggplotly(age_abundance, ttoltip = c("Abundance", "Year"))

```

We can see from figures 1.1 and 1.2, that the age category which is the most similar to the overall abundance shape is Age 1; this is expected due to this age class contributing most to the overall population. At the start, Age 1 makes up half of the population!
After age 1, where the probability of survival to age 2 is below half,  each category gradually declines in size. Age 3 contributes most to Age 1 as its birth rate ($\rho_3 = 1.9$) is double that of Age 2($\rho_2 = 0.9$). Hence, when we see a large increase from one year to the next in Age 1 there is often an increase between those years in Age 3 - this can be seen between years 7 and 8 where there is a large increase in Age 1 which can also be seen in Age 3, but in Age 2 the number of individuals actually decreases between these years.

Comparing our state model to our observation model, we usually see around half of the actual population, which is to be expected with our probability of detection $p = 0.5$.

## Question 2

We are given the model where illegal harvesting is assumed to take place after growth:

$$ N_t = N_{t-1} + r_tN_{t-1}(1 - \frac{N_{t-1}}{K_t} ) - c_{t-1} $$
This is because the measurement of hunting $c$ is assumed to be measured at the end of the year, i.e by the end of year $t-1$, $c_{t-1}$ million Wildebeest have been killed and hence this will be taken off the measurement of year $t$. However if we want to harvest *before* growth, we would assume $c$ represents that it knows the number of Wildebeest which will be killed this year. Hence if we want the model to reflect this case we would use model:

$$ N_t = N_{t-1} + r_tN_{t-1}(1 - \frac{N_{t-1}}{K_t} ) - c_t $$

- does it make more sense to model $r_t$ as a function of rainfall in time $t$ or time $t-1$? (neither is wrong, focus on interpreting the biological sequencing implied by the model)
 

A few sentences here. What is your choice, and why. I would make sense to model X as a function of X because X. 

- does it make more sense to model $K_t$ as a function of rainfall in time $t$ or time $t-1$? (again, neither is wrong)

The carrying capacity, $K_t$ of Wildebeest at time t is dependent on a few factors in their habitat. These include: Food supply, water supply, habitat space and competition. 
Wildebeest have a diet that consists strictly of grazing. Intuitively, this would depend on the rainfall of the current year; the effects of droughts can be very rapid and cause grass to dry out on a timescale of weeks, which may instantaneously affect any animal population that depend on it.  
However, a study in the Journal of Ecology [Joan Dudney et al. 2017] suggests that the lagged rainfall may have a significant influence over the abundance of plant species in annual-dominated grasslands. They also note that "the effect of previous-year precipitation was greater for forbs than grasses, indicating that rainfall-induced biotic effects
strongly constrain forb growth and weakly impact grasses." It would seem that there is at least some effect of a previous year's rainfall on the abundance of our Wildebeests' favoured food.  
Another study [Gundula S. Bartzke et al.] notes that "the increasing rainfall extremes in the Mara can be expected to create conditions conducive to outbreaks of infectious animal diseases and reduced vegetation quality for herbivores, particularly when droughts and floods persist over multiple years'. It may therefore be useful for ecologists to incorporate the effect of long drought periods. 
However, the effects of rainfall measured in the current year are much greater in comparison. There is a much clearer pattern between rainfall and the growth of vegetation at smaller timescales which would indicate that a model for $K_t$ based on $r_{t-1}$ will be more informative. [need a citation? or none at all?]

$$ N_t = N_{t-1} + r_{t}N_{t-1}(1 - \frac{N_{t-1}}{K_t} ) - c_{t-1} $$


## Question 3
#### part b

As discussed in question 2 part b, we would like to find out whether it is more appropriate to model the carrying capacity of the wildebeest, $K_t$. To do this, we can make a function that returns the projection of the wildebeest population and also the negative log likelihood for each model, K_rain. 
The projection model we will use is:
$$ N_t = N_{t-1} + r_{t}N_{t-1}(1 - \frac{N_{t-1}}{K_t} ) - c_{t-1} $$
where:
$$ K_{t_1} = exp(\beta_0 + \beta_1 R_{t})$$
and 
$$ K_{t_2} = exp(\beta_0 + \beta_1 R_{t-1})$$

Keeping the growth parameter $r_t$ fixed.


``` {r}
library(statsecol)
data("wildebeest")
K_rain <- function(pars, years, removals, Nhat, Sehat, rain, model = 1, type = "proj"){

  #define variables from the inputs
  N0 <- exp(pars[1])
  N <- k <- numeric(years)
  r <- rep(exp(pars[2]), years)
  
  N[1] <- N0
  k[1] <- NA
  
  beta <- pars[c(3, 4)]
  
  for (i in 2:years){
    if(model == 1) {
      k[i] <- exp(beta[1]+beta[2]*rain[i])
    }
    if(model == 2) {
      k[i] <- exp(beta[1]+beta[2]*rain[i-1])
    }
    N[i] = N[i-1] + r[i] * N[i-1] * (1-N[i-1]/k[i]) - removals[i-1]
  }
  negloglik <- -sum(dnorm(Nhat,N,Sehat, log=TRUE), na.rm=TRUE)
  
  if(type=="nll"){ return(negloglik)}
  if(type=="proj"){ return(N)}
  
}
```
This also depends on the parameters: N0, the initial population; The growth parameter; $\beta_0$ and $\beta_1$, the parameters that govern the carrying capacity.
To fit our parameters, we begin with the following estimates:
```{r, echo = TRUE}
N0 <- log(0.268)
r <- log(0.1)
beta0 <- 0.5
beta1 <- 0.5
pars <- c(N0, r, beta0, beta1)
```
This produces the following models:
```{r, include=TRUE, echo =FALSE}

model1 <- K_rain(model = 1,type = "proj", pars, nrow(wildebeest), wildebeest$Catch, wildebeest$Nhat, wildebeest$sehat, wildebeest$rain)
model2 <- K_rain(model = 2,type = "proj", pars, nrow(wildebeest), wildebeest$Catch, wildebeest$Nhat, wildebeest$sehat, wildebeest$rain)

ggplot(data = wildebeest, 
       mapping = aes(x= year, y =Nhat, ymin = Nhat - sehat, ymax = Nhat + sehat))+
  geom_pointrange()+
  theme_bw() +
  labs(x = "Year", y = "Abundance (millions)",
       title ="Abundance of Wildebeest Populations")+
  geom_line(aes(y = model1, colour = "t"))+
  geom_line(aes(y = model2, colour = "t-1"))
```
This is clearly not very informative. Since our parameter values are the same for each model. We can use optim to fit the paramters and gain greater insight:

```{r, eval = TRUE}
fitm1 <- optim(par = pars, 
                fn = K_rain,
                years = nrow(wildebeest), 
                removals = wildebeest$Catch,
                Nhat = wildebeest$Nhat,
                Sehat = wildebeest$sehat,
                rain = wildebeest$rain,
                model =1,
                type = "nll")

fitm2 <- optim(par = pars, 
                 fn = K_rain,
                 years = nrow(wildebeest), 
                 removals = wildebeest$Catch,
                 Nhat = wildebeest$Nhat,
                 Sehat = wildebeest$sehat,
                 rain = wildebeest$rain,
                 model =2,
                 type = "nll")


fit <- data.frame(par1 = fitm1$par, par2 = fitm2$par)


fitmod1 <- K_rain(model = 1,type = "proj", fit$par1, nrow(wildebeest), 
                  wildebeest$Catch, wildebeest$Nhat, wildebeest$sehat, 
                  wildebeest$rain)
fitmod2 <- K_rain(model = 2,type = "proj", fit$par2, nrow(wildebeest), 
                  wildebeest$Catch, wildebeest$Nhat, wildebeest$sehat, 
                  wildebeest$rain)

```
```{r,  include=TRUE, echo =FALSE}
ggplot(data = wildebeest, 
       mapping = aes(x= year, y =Nhat, ymin = Nhat - sehat, ymax = Nhat + sehat))+
  geom_pointrange()+
  theme_bw() +
  labs(x = "Year", y = "Abundance (millions)",
       title ="Abundance of Wildebeest Populations")+
  geom_line(aes(y = fitmod1, colour = "t"))+
  geom_line(aes(y = fitmod2, colour = "t-1"))
```